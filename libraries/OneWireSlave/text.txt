Библиотека OneWireSlave позволяет использовать ардуину на линии OneWire в качестве ведомого устройства. Подробнее о OneWire можно прочитать здесь (http://robocraft.ru/blog/communication/117.html). Теоретически на линии может быть до 2^48 или 281 триллионов ведомых устройств. С помощью этой библиотеки на одну линию совместно с датчиками температуры и прочими устройствами, использующими протокол OneWire, можно подключить несколько ардуин.

OneWireSlave(uint8_t pin); конструктор, параметром указывается пин ардуины для OneWire линии.
void setRom(char rom[8]); устанавливает тип и адрес устройства. Если библиотека скомпилирована с поддержкой расчета контрольной суммы crc8, то она подсчитывается и заносится в последний байт rom.
bool waitForRequest(bool ignore_errors); функция блокирует выполнение программы и ожидает обращения к текущему устройству. Функция возвращает управление программе, если ведущее устройство отправило команду MATCH ROM с адресом текущего устройства или команду SKIP ROM. Во время ожидания функция принимает участие в поисковых запросах ведущего устройства и отвечает на команду READ ROM. Таким образом обеспечивается поддержка базового протокола. Если параметр ignore_errors установлен, то функция будет игнорировать ошибки чтения/записи, иначе вернет FALSE.
bool waitReset(uint16_t timeout_ms); функция ждет RESET импульса на линии, после чего возвращает управление программе. Параметр timeout_ms устанавливает время в миллисекундах, по истечение которого функция принудительно вернет управление программе. Если timeout_ms равен 0, то программа будет вечно ожидать RESET импульс, пока не дождется. Стандартное значение timeout_ms - 1000. Возвращает TRUE, если принят сигнал RESET, в случае слишком короткого или слишком длинного сигнала или по истечение времени ожидания вернет FALSE.
bool presence(uint8_t delta); функция посылает сигнал PRESENCE согласно протоколу. Если в конце передачи сигнала на линии по какой-либо причине будет низкий уровень сигнала, функция вернет FALSE.
bool search(); функция участвует в процедуре поиска устройств, описанной в документации протокола OneWire. Возвращает TRUE, если при поиске было найдено текущее устройство, иначе FALSE.
uint8_t sendData(char buf[], uint8_t len); отсылает на линию указанный объем данных. Возвращает количество отосланных байт данных.
uint8_t recvData(char buf[], uint8_t len); считывает с линии указанный объем данных и заносит их в указанный буфер. Возвращает количество успешно считанных байт данных.
void send(uint8_t v); отсылает на линию один байт данных.
uint8_t recv(void); считывает с линии один байт данных.
void sendBit(uint8_t v); отсылает на линию один бит данных.
uint8_t recvBit(void); считывает с линии один бит данных.
static uint8_t crc8(char addr[], uint8_t len); функция подсчитывает контрольную сумму по алгоритму crc8 указанного объема данных.
uint8_t errno; Если выполнение функции закончилось неудачей, то она занесет номер ошибки в эту переменную.
Ошибки:
ONEWIRE_NO_ERROR при выполнении функции не возникло никаких исключений.
ONEWIRE_READ_TIMESLOT_TIMEOUT истекло время ожидания таймслота от ведомого устройства при чтении с линии. Устанавливается функциями recv*.
ONEWIRE_WRITE_TIMESLOT_TIMEOUT истекло время ожидания таймслота от ведомого устройства при записи на линию. Устанавливается функциями send*.
ONEWIRE_WAIT_RESET_TIMEOUT истекло время ожидания импульса RESET на линии. Устанавливается функцией waitReset.
ONEWIRE_VERY_LONG_RESET импульс RESET принят, но оказался слишком длинным (возможно это не RESET, а что-то другое). Устанавливается функцией waitReset.
ONEWIRE_VERY_SHORT_RESET импульс RESET оказался слишком коротким. Такая ошибка может появиться, если при ожидании RESET сигнала другое устройство начало передачу данных.
ONEWIRE_PRESENCE_LOW_ON_LINE по окончании передачи PRESENCE сигнала на линии оказывается низкий уровень сигнала. Согласно протоколу все устройства в момент считывания сигнала с линии должны были прекратить передачу импульса PRESENCE.

Пример скетча, эмулирующего работу ключа ibutton с микросхемой DS1990A
#include "WProgram.h"
#include "OneWireSlave.h"

char rom[8] = {0x01, 0xAD, 0xDA, 0xCE, 0x0F, 0x00, 0x00, 0x00};
OneWireSlave ds(8);

void setup() {
    ds.setRom(rom);
}

void loop() {
    ds.waitForRequest(false);
}

В данном случае функция waitForRequest вернет FLASE с ошибкой ONEWIRE_READ_TIMESLOT_TIMEOUT, т.к. домофон (или его эмулятор) не выбирает устройство, а только считывает его адрес.

В случае обрыва линии на выводе может возникнуть неопределенное состояние, поэтому рекомендуется вывод ардуины подключить к земле через резистор 220к.

Заметка: с реальным домофоном без дополнительной обвязки ардуина работать не будет, т.к. в современные домофоны устанавливаются защиты от копированных ключей. Защита срабатывает на основе некоторых электрических и возможно временных параметров.

