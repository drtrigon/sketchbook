<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>sketchbook: HOWTO create a new MoaT 1wire device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sketchbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HOWTO create a new MoaT 1wire device </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Quick intro</h2>
<p>First, look at <code>world.cfg</code>. This is a YAML-formatted file. Its structure is reasonably obvious. Hopefully.</p>
<p>Now copy <code>sample.cfg</code>. We'll use <code>project.cfg</code> subsequently; you should probably use the actual name of your project.</p>
<p>Edit the <code>env</code> section to tell it which programmer you use.</p>
<p>Then, add your slaves to the <code>devices</code> section.</p>
<p>Let's say you want to use three ports of an ATmega88: a PWM output on pin B0, a counter input on B1, and an alarm input on B2. Let's call your slave "try1". So you'd do this: </p>
<pre class="fragment">devices:
  try1:
    _doc: my first test slave
    _ref: defaults.target.m88
    defs:
      is_onewire: moat
    types:
      port: 3
      pwm: 1
      count: 1
    port:
      1: B0_
      2: B1~
      3: B2~*
    pwm:
      1: 1
    count:
      1: 2
</pre><p>Now <code>make CFG=project.cfg try1</code>. Your slave will get a random 1wire ID assigned, which will be auto-added to <code>project.cfg</code>.</p>
<p>Now use <code>make CFG=project.cfg burn_try1</code> to flash your device. There's no need for <code>sudo</code> here, as the Makefile already contains that.</p>
<h2>Definitions</h2>
<p>The <code>MoaT</code> code is pretty modular because basic features should fit in 4kBytes of Flash storage. Therefore you can turn various features on. Or not.</p>
<h3><code>have_uart</code></h3>
<p>This adds basic code to use the serial port.</p>
<h3><code>have_uart_irq</code></h3>
<p>Use this to have the UART be interrupt-based. If this is off, the code will use polling. Note that UART interrupts may disrupt 1wire communication.</p>
<h3><code>have_uart_sync</code></h3>
<p>If this is on, the UART will use neither interrupts nor polling; instead it'll simply wait until the ATmega's send buffer is empty.</p>
<p>Use this for hard-to-find crashes; however, any serial output will disrupt 1wire communication.</p>
<h3><code>have_timer</code></h3>
<p>Set this if your code uses the timer interrupt, i.e. functions from <code><a class="el" href="timer_8h.html">timer.h</a></code>.</p>
<h3><code>have_watchdog</code></h3>
<p>Turns on the watchdog timer at the start of the program. Uses the longest-possible timeout.</p>
<p>If you're using MoaT, this means that you have to poll the bus, using CONDITIONAL SEARCH, every eight seconds; to be safe, you should poll at least every five seconds). This should be sufficient to restart a polling server.</p>
<h3><code>debug_uart</code></h3>
<p>If you need to debug the low-level UART code itself, set this. Should not be necessary.</p>
<h3><code>debug_onewire</code></h3>
<p>If you need to debug the low-level 1wire code itself, set this. Should not be necessary.</p>
<h3><code>uart_debug</code></h3>
<p>The debugger macros from <code><a class="el" href="debug_8h.html">debug.h</a></code> will send their data to the UART. Only do this if you connect a serial terminal to your ATmega. Do not use this when debugging UART itself.</p>
<h3><code>console_debug</code></h3>
<p>The debugger macros from <code><a class="el" href="debug_8h.html">debug.h</a></code> will send their data to the 1wire console buffer. Do not use this when debugging 1wire itself.</p>
<h3><code>console_write</code></h3>
<p>You can write to the console via 1wire. This is not yet useful, except for echo testing.</p>
<h3><code>console_ping</code></h3>
<p>Write a '!' every N tenths-of-a-second, as a keepalive test. Needs the timer.</p>
<h3><code>have_dbg_port</code></h3>
<p>Use a port for diagnostic code output. Which port to use is defined in <code><a class="el" href="features_8h.html">features.h</a></code>. The <a class="el" href="debug_8h.html#a32adf79142f0a426b5e782fb7cd4cad3">DBG(x)</a> macro will then take the binary value of X and display it on the port in question. Useful for low-level timing analysis using a 'scope with digital inputs, or to discover where your slave code crashes.</p>
<h3><code>have_dbg_pin</code></h3>
<p>Use a pin for diagnostic signalling. Which pin to use is defined in <code><a class="el" href="features_8h.html">features.h</a></code>. The <code><a class="el" href="onewire_8c.html#a93e505e4e4e1119ed32afcb615b385f6">DBG_ON()</a></code>/<code><a class="el" href="onewire_8c.html#ac037b21720571ebb0110174b826ccaac">DBG_OFF()</a></code> macros will turn this pin on or off. Useful for low-level timing analysis using a 'scope with a trigger input.</p>
<h3><code>is_onewire</code></h3>
<p>The 1wire device type (moat, ds2408, ds2423). <code>moat</code> is tested, everything else has not been, lately.</p>
<h3><code>need_bits</code></h3>
<p>Include code required to send or receive single bits on 1wire.</p>
<h3><code>use_eeprom</code></h3>
<p>Store configuration data in EEPROM. This may or may not make config data actually writeable.</p>
<h3><code>conditional_search</code></h3>
<p>Make your 1wire slave discoverable conditionally. You can configure which conditions may cause an alarm.</p>
<h3><code>single_device</code></h3>
<p>Add 1wire code for <code>SKIP_ROM</code> and <code>READ_ROM</code>. You probably do not need this.</p>
<h3><code>onewire_io</code></h3>
<p>Choose which pin to connect your 1wire bus to. For now, only pins with dedicated interrupts (INTx) can be used. On an ATmega168, these are pins D2 and D3.</p>
<p>The default is INT0.</p>
<h2>Features</h2>
<p>The MoaT slave code can do a lot of things. You can use the device's <code>types</code> section to control what gets included (and, for some features, how many).</p>
<h3>port</h3>
<p>Your basic digital input/output pin. Your ATmega device's data sheet names them "B0" or "D7" or whatever. On the 1wire side, pins are numbered 1 to N. Use the <code>port</code> section to tell MoaT which pin numbers correspond to which hardware output.</p>
<p>Pins can have one of four states:</p>
<ul>
<li><code>^</code>: One or High, i.e. tied to +5V (or whatever voltage you use).</li>
<li><code>_</code>: Zero or Low, i.e. tied to ground.</li>
<li><code>+</code>: Pull-Up, i.e. tied to +5V (or whatever) via an internal resistor, so that an external input can still ground it ("wired-AND").</li>
<li><code>~</code>: High impedance, i.e. sensing whether the input is 1 or 0 passively.</li>
</ul>
<p>Reading the pin will return whatever signal is physically present. Writing to the pin may or may not change its state. Typically, an output will switch between 0 and 1. If you write to an input, you can turn the pull-up resistor on and off.</p>
<p>This is not always what you want: if you have a wired-AND pin, you'd want to switch between "pull-up is on" and "pull-down to zero". You can do that by adding a <code>/</code> to the port description. Alternately, if you have an external pull-up resistor, you can add <code>!</code>, which switches between "high
impedance" and "pull-down to zero", instead. These modifiers also apply to the other two states (i.e. a port marked with <code>+!</code> will switch between Pull-Up and One), but that's usually not useful.</p>
<p>Please do not bother this author with Arduino-based port numbers.</p>
<p>Thus, if you want to write B0 (initially low) and read/write B1 (with pull-up): </p>
<pre class="fragment">types:
  port: 2
port:
  1: B0_
  2: B1+/
</pre><h3>pwm</h3>
<p>You can tell MoaT to switch a port on and off periodically. Let's say you want to toggle B1 every second, you'd extend the above example thus: </p>
<pre class="fragment">types:
  port: 2
  pwm: 1
port:
  1: B0_
  2: B1+/
pwm:
  1: 2
</pre><p>and then "owwrite /F0.123456789ABC.DE/pwm.1 10,10"</p>
<p>This is (almost) as accurate as the clock of your ATmega, and a lot more efficient than sending a command every second.</p>
<h3>count</h3>
<p>If you're more interested in how often an input pin changes state than in its actual state, you should use a counter.</p>
<p>Let's add the counted input pin D5 to our example: </p>
<pre class="fragment">types:
  port: 2
  pwm: 1
  count: 1
port:
  1: B0_
  2: B1+/
  3: D5~
count:
  1: 3
</pre><p>You can now <code>owread /F0.123456789ABC.DE/count.1</code>.</p>
<p>You can choose which transition to count (low/high, high/low, or both) and whether to raise an alarm when the counter increases.</p>
<h3>temp</h3>
<p>Read a thermometer (or two). The only driver that's implemented right now is a test driver that returns slowly-varying dummy values. </p>
<pre class="fragment">types:
  temp: 1
temp:
  - dummy=1
</pre><p>TODO: read "real" temperature</p>
<h3>adc</h3>
<p>You can read voltages from the A/D converters. In addition to the ATmega's external ADC ports, yo can read the bandgap voltage (roughly 1.1V) and the temperature sensor (which is not very accurate).</p>
<p>All voltages are returned as an integer: 65535 times the fraction of the supply voltage. You can use the bandgap voltage if you add a <code>-</code> to the config statement.</p>
<p>As an example, with this statement </p>
<pre class="fragment">types:
  adc: 5
adc:
  - 0
  - 2-
  - R
  - T
  - G
</pre><p><code>owread /F0.123456789ABC.DE/adc.1</code> will measure ADC0 as a fraction of +5V (or whatever). Reading <code>adc.2</code> will measure ADC2 as a fraction of 1.1V, thus being somewhat more accurate if you need to read small voltages. <code>adc.3</code> will return something close to 14419, i.e. 65535*(Vdd/Vbg), assuming your supply voltage is +5V. <code>adc.4</code> will read the voltage of the ATmega's temperature sensor. <code>adc.5</code>, finally, returns the voltage of the ground pin, which should obviously be zero; usually it's offset by one or two bits, which gives you a rough estimate of the accuracy of the ADC converter.</p>
<p>Note that accurate ADC readings depend on (a) the quality of the ADC's power supply, (b) on the ATmega doing as little as possible during conversion. (a) is your responsibility; check the data sheet. (b) is more of a problem.</p>
<p>Note that MoaT continuously polls all configured ADC ports. Reading 1wire does not actually start the ADC, it just returns the latest value. I decided against adding an explicit "start conversion" command because the most common usage is not to poll the MoaT slave. Instead, you'd read once and then write trigger values which cause an alert when crossed. Thus, the MoaT slave needs to poll the ADC anyway.</p>
<h3>serial</h3>
<p>TODO: connect one of the console channels to the serial port.</p>
<h3>fire</h3>
<p>TODO: implement the Gira Dual smoke detector's serial protocol on the slave.</p>
<h3>Loader</h3>
<p>TODO: firmware update over 1wire. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 24 2019 21:30:39 for sketchbook by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
